#!/usr/bin/env ipython3

# Henrik's test framework

import time
import datetime
import errno
import os
import signal
import sys
import time
import plumbum
import io
from plumbum import local, FG, BG
from plumbum.cmd import bash, tmux, ssh
import subprocess

from calc_queuedelay import QueueDelay
from calc_utilization import Utilization
from plot import Plot, getTestcasesInFolder

def get_shell_cmd(cmd_object):
    """Convert a plumbum cmd to a shell expression"""
    return ' '.join(cmd_object.formulate(10))

class Common():
    pids_to_kill = []

    @staticmethod
    def require_on_aqm_node():
        bash['-c', 'source ../common.sh; require_on_aqm_node'] & FG

    def kill_known_pids(self):
        for pid in self.pids_to_kill:
            Common.kill_pid(pid)

        self.pids_to_kill = []

    @staticmethod
    def kill_pid(pid):
        try:
            os.kill(pid, signal.SIGTERM)
        except ProcessLookupError:
            pass

    @staticmethod
    def is_running(pid):
        try:
            os.kill(pid, 0)
        except OSError as err:
            if err.errno == errno.ESRCH:
                return False
        return True

    @staticmethod
    def waitpid(pid):
        try:
            os.waitpid(pid, 0)
        except ChildProcessError:
            pass


class Terminal():
    def __init__(self):
        pass

    def cleanup(self):
        pass

    def run_fg(self, cmd, verbose=False):
        cmd = get_shell_cmd(cmd)
        if verbose:
            print(cmd)

        p = bash['-c', cmd].popen(stdin=None, stdout=None, stderr=None, close_fds=True)
        return p.pid

    def run_bg(self, cmd, verbose=False):
        cmd = get_shell_cmd(cmd)
        if verbose:
            print(cmd)

        p = bash['-c', cmd].popen(stdin=subprocess.DEVNULL, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, close_fds=True)
        return p.pid


class Tmux(Terminal):
    win_id = None
    win_bg_id = None

    def __init__(self):
        if 'TMUX' not in os.environ:
            raise Exception("Please run this inside a tmux session")

        self.win_id = tmux['display-message', '-p', '#{window_id}']().strip()
        tmux['set-window-option', '-t', self.win_id, 'remain-on-exit', 'on']()

        self.cleanup()

    def cleanup(self):
        self.kill_dead_panes()

    def kill_dead_panes(self):
        (tmux['list-panes', '-s', '-F', '#{pane_dead} #{pane_id}'] | local['grep']['^1'] | local['awk']['{print $2}'] | local['xargs']['-rL1', 'tmux', 'kill-pane', '-t']).run(retcode=None)

    def run_fg(self, cmd, verbose=False):
        cmd = get_shell_cmd(cmd)
        if verbose:
            print(cmd)

        pane_pid = tmux['split-window', '-dP', '-t', self.win_id, '-F', '#{pane_pid}', cmd]().strip()

        tmux['select-layout', '-t', self.win_id, 'tiled']()
        return int(pane_pid)

    def run_bg(self, cmd, verbose=False):
        cmd = get_shell_cmd(cmd)
        if verbose:
            print(cmd)

        # create the window if needed
        # output in the end should be the new pid of the running command
        # so that we can stop it later
        if not self.have_bg_win():
            res = tmux['new-window', '-dP', '-F', '#{window_id} #{pane_pid}', cmd]().strip().split()
            self.win_bg_id = res[0]
            pane_pid = res[1]
            tmux['set-window-option', '-t', self.win_bg_id, 'remain-on-exit', 'on'] & FG

        else:
            pane_pid = tmux['split-window', '-dP', '-t', self.win_bg_id, '-F', '#{pane_pid}', cmd]().strip()
            tmux['select-layout', '-t', self.win_bg_id, 'tiled'] & FG

        return int(pane_pid)

    def have_bg_win(self):
        if self.win_bg_id == None:
            return False

        res = (tmux['list-windows', '-F', '#{window_id}'] | local['grep'][self.win_bg_id]).run(retcode=None)[1].strip()

        return len(res) > 0


class Testbed():
    bitrate = 1000000
    rtt_clients = 0  # in ms
    rtt_servera = 0  # in ms
    rtt_serverb = 0  # in ms
    aqm_name = ''
    aqm_params = ''
    cc_a = 'cubic'
    ecn_a = 2  # 2 = allow ecn, 1 = force ecn, 0 = no ecn
    cc_b = 'cubic'
    ecn_b = 2

    def aqm_default(self):
        self.aqm_name = ''
        self.aqm_params = ''

    def aqm_pi2(self):
        self.aqm_name = 'pi2'
        self.aqm_params = 'dualq limit 1000'  # l_thresh 10000"

    def aqm_red(self):
        self.aqm_name = 'red'
        self.aqm_params = 'limit 1000000 avpkt 1000 ecn adaptive bandwidth %d' % self.bitrate

    def aqm_dualq(self):
        self.aqm_name = 'dualq'
        self.aqm_params = 'l_thresh_us 1000 offset 0 l_slope 5 c_slope 4 l_smooth 0 c_smooth 5 l_power 1 c_power 2 l_shift 50'

    def setup(self, dry_run=False):
        cmd = bash['-c', """
            source ../common.sh

            configure_clients_edge """ + '%s %s %s "%s"' % (self.bitrate, self.rtt_clients, self.aqm_name, self.aqm_params) + """
            configure_server_edge $IP_SERVERA_MGMT $IP_AQM_SA $IFACE_SERVERA $IFACE_ON_SERVERA """ + str(self.rtt_servera) + """
            configure_server_edge $IP_SERVERB_MGMT $IP_AQM_SB $IFACE_SERVERB $IFACE_ON_SERVERB """ + str(self.rtt_serverb) + """

            configure_host_cc $IP_CLIENTA_MGMT """ + '%s %s' % (self.cc_a, self.ecn_a) + """
            configure_host_cc $IP_SERVERA_MGMT """ + '%s %s' % (self.cc_a, self.ecn_a) + """
            configure_host_cc $IP_CLIENTB_MGMT """ + '%s %s' % (self.cc_b, self.ecn_b) + """
            configure_host_cc $IP_SERVERB_MGMT """ + '%s %s' % (self.cc_b, self.ecn_b) + """
            """]

        if dry_run:
            print(get_shell_cmd(cmd))
        else:
            cmd & FG

    def reset(self, dry_run=False):
        cmd = bash['-c', """
            source ../common.sh
            reset_aqm_client_edge
            reset_aqm_server_edge
            reset_all_hosts_edge
            reset_all_hosts_cc
            """]

        if dry_run:
            print(get_shell_cmd(cmd))
        else:
            cmd & FG

    def get_aqm_options(self, name):
        res = !bash -c 'source ../common.sh; get_aqm_options $name'
        return res.s.strip()

    def print_setup(self):
        print("Configured testbed:")
        print("  rate: %s (applied from router to clients)" % self.bitrate)
        print("  rtt to router:")
        print("    - clients: %d ms" % self.rtt_clients)
        print("    - servera: %d ms" % self.rtt_servera)
        print("    - serverb: %d ms" % self.rtt_serverb)

        if self.aqm_name != '':
            params = ''
            if self.aqm_params != '':
                params = ' (%s)' % self.aqm_params


            print("  aqm: %s%s" % (self.aqm_name, params))
            print("       (%s)" % self.get_aqm_options(self.aqm_name))
        else:
            print("  no aqm")

        for node in ['CLIENTA', 'CLIENTB', 'SERVERA', 'SERVERB']:
            ip = 'IP_%s_MGMT' % node

            print('  %s: ' % node.lower(), end='')
            res = (bash['-c', 'source ../common.sh; get_host_cc "%s"' % ip] | local['tr']['\\n', ' '])().strip()
            print(res)
            #res = !bash -c "source ../common.sh; get_host_cc '$${{$ip}}' | tr '\n' ' '"
            #print(res[0].strip())

    @staticmethod
    def analyze_results(testfolder, dry_run=False):
        if dry_run:
            print("Cannot determine bitrate in dry run mode, setting to -1")
            bitrate = -1

        else:
            bitrate = 0
            with open(testfolder + '/details', 'r') as f:
                for line in f:
                    if line.startswith('testbed_rate'):
                        bitrate = int(line.split()[1])
                        break

            if bitrate == 0:
                raise Exception("Could not determine bitrate of test '%s'" % testfolder)

        fairness = "e"         # used to calculate rPDF, we don't use it now
        nbrf = 0               # used to calculate rPDF, we don't use it now
        rtt_l4s = 0            # used to calculate window size, we don't use it now
        rtt_classic = 0        # used to calculate window size, we don't use it now
        nbr_l4s_flows = 1      # used to generate rPDF and dmPDF, we don't use it now
        nbr_classic_flows = 1  # used to generate rPDF and dmPDF, we don't use it now

        cmd = local['../../traffic_analyzer/calc_henrste'][testfolder, fairness, str(nbrf), str(bitrate), str(rtt_l4s), str(rtt_classic), str(nbr_l4s_flows), str(nbr_classic_flows)]
        print(get_shell_cmd(cmd))

        if dry_run:
            print("Skipping post processing due to dry run")

        else:
            cmd()

            qd = QueueDelay()
            qd.processTest(testfolder)

            u = Utilization()
            u.processTest(testfolder, bitrate)

    def save_hint(self, f, dry_run=False):
        f.write("testbed_rtt_clients %d\n" % self.rtt_clients)
        f.write("testbed_rtt_servera %d\n" % self.rtt_servera)
        f.write("testbed_rtt_serverb %d\n" % self.rtt_serverb)
        f.write("testbed_cc_a %s %d\n" % (self.cc_a, self.ecn_a))
        f.write("testbed_cc_b %s %d\n" % (self.cc_b, self.ecn_b))
        f.write("testbed_aqm %s\n" % self.aqm_name)
        f.write("testbed_aqm_params %s\n" % self.aqm_params)
        if dry_run:
            f.write("testbed_aqm_params_full UNKNOWN IN DRY RUN\n")
        else:
            f.write("testbed_aqm_params_full %s\n" % self.get_aqm_options(self.aqm_name))
        f.write("testbed_rate %s\n" % self.bitrate)


class TestUtils():
    set_folder = None
    testnum = 0
    testfolders = []  # list of completed tests

    common = None
    terminal = None
    is_interactive = False  # run in tmux or not
    ta_idle = 3  # time to wait before collecting traffic
    ta_delay = 1000
    ta_samples = 60
    traffic_port = 5500
    dry_run = False

    def __init__(self, common, set_folder):
        self.common = common
        self.set_folder = set_folder

        Common.require_on_aqm_node()

        def exit_gracefully(signum, frame):
            self.common.kill_known_pids()
            self.get_terminal().cleanup()
            sys.exit()

        signal.signal(signal.SIGINT, exit_gracefully)
        signal.signal(signal.SIGTERM, exit_gracefully)

    def get_next_traffic_port(self):
        tmp = self.traffic_port
        self.traffic_port += 1
        return tmp

    def get_terminal(self):
        if self.terminal == None:
            self.terminal = Tmux() if self.is_interactive else Terminal()
        return self.terminal

    def run(self, cmd, bg=False, verbose=False):
        if bg:
            return self.get_terminal().run_bg(cmd, verbose=verbose)
        else:
            return self.get_terminal().run_fg(cmd, verbose=verbose)

    def run_greedy(self, node='a'):
        """
        Run greedy TCP traffic

        Greedy = always data to send, full frames

        node: a or b (a is normally classic traffic, b is normally l4s)

        Returns a lambda to stop the traffic
        """
        server_port = self.get_next_traffic_port()

        node = 'A' if node == 'a' else 'B'

        self.save_hint('traffic=tcp type=greedy node=%s%s server=%s' % (node, node, server_port))

        cmd1 = ssh['-tt', os.environ['IP_SERVER%s_MGMT' % node], '/opt/testbed/greedy_generator/greedy -vv -s %d' % server_port]
        cmd2 = ssh['-tt', os.environ['IP_CLIENT%s_MGMT' % node], 'sleep 0.2; /opt/testbed/greedy_generator/greedy -vv %s %d' % (os.environ['IP_SERVER%s' % node], server_port)]

        if self.dry_run:
            print(get_shell_cmd(cmd1))
            print(get_shell_cmd(cmd2))

            def stopTest():
                pass

        else:
            pid_server = self.run(cmd1, bg=True, verbose=True)
            pid_client = self.run(cmd2, bg=True, verbose=True)
            self.common.pids_to_kill.append(pid_server)
            self.common.pids_to_kill.append(pid_client)

            def stopTest():
                Common.kill_pid(pid_server)
                Common.kill_pid(pid_client)

        return stopTest

    def run_udp(self, bitrate, node='a', ect="nonect"):
        """
        Run UDP traffic at a constant bitrate

        ect: ect0 = ECT(0), ect1 = ECT(1), all other is Non-ECT

        Returns a lambda to stop the traffic
        """

        tos = ''
        if ect == 'ect1':
            tos = "--tos 0x01" # ECT(1)
        elif ect == 'ect0':
            tos="--tos 0x02" # ECT(0)
        else:
            ect = 'nonect'

        server_port = self.get_next_traffic_port()

        node = 'A' if node == 'a' else 'B'

        self.save_hint('traffic=udp node=%s%s client=%s rate=%d ect=%s' % (node, node, server_port, bitrate, ect))

        cmd_server = ssh['-tt', os.environ['IP_CLIENT%s_MGMT' % node], 'iperf -s -p %d' % server_port]

        # bitrate to iperf is the udp data bitrate, not the ethernet frame size as we want
        framesize = 1514
        headers = 42
        length = framesize - headers
        bitrate = bitrate * length / framesize

        cmd_client = ssh['-tt', os.environ['IP_SERVER%s_MGMT' % node], 'sleep 0.5; iperf -c %s -p %d %s -u -l %d -R -b %d -i 1 -t 99999' %
                          (os.environ['IP_CLIENT%s' % node], server_port, tos, length, bitrate)]

        if self.dry_run:
            print(get_shell_cmd(cmd_server))
            print(get_shell_cmd(cmd_client))

            def stopTest():
                pass

        else:
            pid_server = self.run(cmd_server, bg=True, verbose=True)
            pid_client = self.run(cmd_client, bg=True, verbose=True)

            self.common.pids_to_kill.append(pid_server)
            self.common.pids_to_kill.append(pid_client)

            def stopTest():
                Common.kill_pid(pid_client)
                Common.kill_pid(pid_server)

        return stopTest

    def run_speedometer(self, max_bitrate, delay=0.5):
        max_bitrate = max_bitrate / 8

        cmd = local['speedometer']['-s', '-i', '%f' % delay, '-l', '-t', os.environ['IFACE_CLIENTS'], '-m', '%d' % max_bitrate]

        if self.dry_run:
            print(get_shell_cmd(cmd))
        else:
            pid = self.run(cmd, verbose=True)
            self.common.pids_to_kill.append(pid)

    def run_ta(self, bg=False):
        net = !echo $IP_AQM_C | sed 's/\.[0-9]\+$/.0/'
        net = net[0]

        pcapfilter = 'ip and dst net %s/24 and (tcp or udp)' % net
        ipclass = 'f'

        cmd = bash['-c', "echo 'Idling a bit before running ta...'; sleep %f; ../../traffic_analyzer/ta $IFACE_CLIENTS '%s' '%s' %d %s %d" %
                   (self.ta_idle, pcapfilter, self.get_testfolder(), self.ta_delay, ipclass, self.ta_samples)]

        if self.dry_run:
            pid = -1
            print(get_shell_cmd(cmd))
        else:
            pid = self.run(cmd, verbose=True, bg=bg)

            # we add it to the kill list in case the script is terminated
            self.common.pids_to_kill.append(pid)

        return pid

    def run_monitor_setup(self):
        cmd = local['watch']['-n', '.2', '../show_setup.sh', '-vir', '%s' % os.environ['IFACE_CLIENTS']]

        if self.dry_run:
            print(get_shell_cmd(cmd))
        else:
            pid = self.run(cmd, verbose=True)
            self.common.pids_to_kill.append(pid)

    def save_hint_set(self, text):
        if self.dry_run:
            print("hint(set): " + text)
        else:
            TestUtils.save_hint_to_folder(self.set_folder, text)

    def save_hint(self, text):
        if self.dry_run:
            print("hint(test): " + text)
        else:
            TestUtils.save_hint_to_folder(self.get_testfolder(), text)

    @staticmethod
    def save_hint_to_folder(folder, text):
        os.makedirs(folder, exist_ok=True)

        print("hint: ", text)
        with open(folder + '/details', 'a') as f:
            f.write(text + '\n')

    @staticmethod
    def remove_hint(folder):
        file = folder + '/details'
        if os.path.isfile(file):
            os.remove(file)

    def get_testfolder(self):
        tag = '' if self.testtag is None else '-%s' % self.testtag
        return self.set_folder + '/test-' + self.get_testnum() + tag

    def get_testnum(self):
        return '%03d' % self.testnum

    def run_test(self, the_test, testbed, tag=None, xticlabel=None, xaxislabel=None):
        """Run a single test (the smallest possible test)

        the_test: Method that generates test data
        tag: String appended to test case directory name
        xticlabel: The x label value for this specific test when aggregated
        xaxislabel: Description of the xtic values
        """

        self.testtag = tag

        self.testnum += 1
        testfolder = self.get_testfolder()

        print()
        print()
        print('-------- TESTCASE %s --------' % testfolder)
        print(str(datetime.datetime.now()))
        print()

        start = time.time()

        testbed.reset(dry_run=self.dry_run)
        testbed.setup(dry_run=self.dry_run)

        print('%.2f s: Testbed initialized, starting test' % (time.time()-start))
        print()

        if self.dry_run:
            f = io.StringIO()
            testbed.save_hint(f, dry_run=True)
            print(f.getvalue())
        else:
            !rm -R $testfolder
            !mkdir -p $testfolder

        self.save_hint('type test')
        self.save_hint('xticlabel %s' % ('' if xticlabel is None else xticlabel))
        self.save_hint('xaxislabel %s' % ('' if xaxislabel is None else xaxislabel))

        if not self.dry_run:
            with open(testfolder + '/details', 'a') as f:
                testbed.save_hint(f)

        if self.is_interactive:
            pid_ta = self.run_ta()
            self.run_monitor_setup()
            self.run_speedometer(testbed.bitrate * 1.1, delay=0.05)
        else:
            pid_ta = self.run_ta(bg=True)

        the_test(self, testbed)

        if not self.dry_run:
            Common.waitpid(pid_ta)  # wait until 'ta' quits

        self.common.kill_known_pids()

        print()
        print('%.2f s: Data collection finished' % (time.time()-start))

        Testbed.analyze_results(self.get_testfolder(), dry_run=self.dry_run)
        self.get_terminal().cleanup()

        print()
        print('%.2f s: Plotting complete, test ending' % (time.time()-start))

        self.testfolders.append(testfolder)


class TestCollection():
    """Organizes test sets in collections and stores metadata used to automatically plot

    Test hierarchy looks like (from bottom up):
    - single tests
    - sets of single tests
    - collection of sets
    - collection of collections, and so on
    """
    title = None
    folder = None
    parent = None
    parent_called = False

    def __init__(self, folder, title=None, parent=None):
        self.title = title
        self.folder = folder
        self.parent = parent

        TestUtils.remove_hint(folder)
        TestUtils.save_hint_to_folder(folder, 'type collection')

        if title is not None:
            TestUtils.save_hint_to_folder(folder, 'title %s' % title)

    def add_set(self, testenv):
        TestUtils.save_hint_to_folder(self.folder, 'sub %s' % os.path.basename(testenv.set_folder))

        if self.parent and not self.parent_called:
            self.parent_called = True
            self.parent.add_collection(self)

    def add_collection(self, collection):
        TestUtils.save_hint_to_folder(self.folder, 'sub %s' % os.path.basename(collection.folder))


class TestbedTesting():
    def testbed(self):
        testbed = Testbed()
        testbed.bitrate = 10*1000*1000
        testbed.aqm_pi2()
        testbed.rtt_servera = 25
        testbed.rtt_serverb = 25
        testbed.cc_b = 'dctcp'
        testbed.ecn_b = 1
        return testbed

    def run_set(self, method_set, testbed, set_folder, plot_only=False, title=None):
        common = Common()
        self.testutils = TestUtils(common, set_folder)

        if plot_only:
            self.testutils.dry_run = True

        if not self.testutils.dry_run:
            TestUtils.remove_hint(self.testutils.set_folder)

        if title is not None:
            self.testutils.save_hint_set('title %s' % title)

        method_set(self.testutils)

        self.testutils.save_hint_set('type set')

        self.generate_set_plots()

    def run_test(self, the_test, testbed, **kwargs):
        self.testutils.run_test(the_test, testbed, **kwargs)
        self.testutils.save_hint_set('sub %s' % os.path.basename(self.testutils.get_testfolder()))

        # plot this single flow
        p = Plot()
        p.plot_flow(self.testutils.get_testfolder())

    def generate_set_plots(self):
        if self.testutils.dry_run:
            return

        testcases = self.testutils.testfolders

        p = Plot()
        p.plot_multiple_flows(testcases, self.testutils.set_folder + '/analysis_merged')


class OverloadTesting(TestbedTesting):
    def test_simple(self):
        testbed = self.testbed()

        for numflows in [1,2,3]:
            for cc, ecn, tag, title in [('cubic', 2, 'cubic',    'cubic vs cubic'),
                                        ('cubic', 1, 'cubic-ecn','cubic vs cubic-ecn'),
                                        ('dctcp', 1, 'dctcp',    'cubic vs dctcp')]:
                testbed.cc_b = cc
                testbed.ecn_b = ecn

                def my_set(testenv):
                    for rtt in [2, 5, 10, 25, 50, 75, 100, 125, 150, 175, 200, 250, 300, 400]:
                        testbed.rtt_servera = rtt
                        testbed.rtt_serverb = rtt
                        testenv.ta_idle = (rtt / 1000) * 20 + 4

                        def my_test(testenv, testbed):
                            for i in range(numflows):
                                testenv.run_greedy(node='a')
                                testenv.run_greedy(node='b')

                        testenv.run_test(my_test, testbed, tag=rtt, xticlabel=rtt)

                self.run_set(my_set, testbed, 'testset-simple/flows-%d/%s' % (numflows, tag), title=title, xticlabel='RTT')

    def test_increasing_udp_traffic(self):
        """Test UDP-traffic in both queues with increasing bandwidth"""
        testbed = self.testbed()

        def my_set(testenv):
            def my_test(testenv, testbed):
                for x in range(10):
                    testenv.run_udp(node='a', bitrate=1250000, ect='nonect')
                    testenv.run_udp(node='b', bitrate=1250000, ect='ect0')
                    time.sleep(2)

            testenv.run_test(my_test, testbed)
            testenv.run_test(my_test, testbed)
            testenv.run_test(my_test, testbed)

        self.run_set(my_set, testbed, 'testsets/increasing-udp')

    def test_speeds(self):
        """Test one UDP-flow vs one TCP-greedy flow with different UDP speeds and UDP queue"""
        testbed = self.testbed()

        for ect in ['nonect', 'ect1']:
            def my_set(testenv):
                testenv.ta_samples = 250
                testenv.ta_delay = 500
                testenv.ta_idle = 5

                speeds = [5000, 9000, 9500, 10000, 10500, 11000, 12000, 12500,
                          13000, 13100, 13200, 13400, 13500, 14000, 28000, 50000, 500000]

                for speed in speeds:
                    def my_test(testenv, testbed):
                        testenv.save_hint('x_udp_rate %d' % (speed * 1000))
                        testenv.run_greedy(node='b')
                        testenv.run_udp(node='a', bitrate=speed*1000, ect=ect)

                    testenv.run_test(my_test, testbed)

            self.run_set(my_set, testbed, 'testsets/speeds/' + ect)

    def test_tcp_competing(self):
        testbed = self.testbed()
        testbed.aqm_pi2()
        testbed.cc_a = 'cubic'
        testbed.ecn_a = 1
        testbed.cc_b = 'cubic'
        testbed.ecn_b = 2

        def my_set(testenv):
            def my_test(testenv, testbed):
                testenv.run_greedy(node='a')
                testenv.run_greedy(node='b')

            testenv.run_test(my_test, testbed)

        self.run_set(my_set, testbed, 'testsets/tcp-competing')

    def test_plot_test_data(self):
        testbed = self.testbed()
        testbed.aqm_pi2()

        test_collection = TestCollection('testsets/plot-testdata', title='Testing cubic vs different flows')

        def my_test1(testenv, testbed):
            testenv.run_greedy(node='a')
            testenv.run_greedy(node='b')

        def my_test2(testenv, testbed):
            testenv.run_greedy(node='a')

        def my_test3(testenv, testbed):
            testenv.run_greedy(node='b')

        for name, my_test, title in [('traffic-ab', my_test1, 'traffic both machines'),
                                     ('traffic-a',  my_test2, 'traffic only a'),
                                     ('traffic-b',  my_test3, 'traffic only b')]:
            def my_set(testenv):
                testenv.ta_samples = 5
                testenv.ta_idle = .5
                testenv.ta_delay = 500

                #for rtt in [2, 5, 10, 20, 50]:
                for rtt in [10, 20, 50]:
                    testbed.rtt_servera = testbed.rtt_serverb = rtt
                    self.run_test(my_test, testbed, tag='rtt-%s' % rtt, xticlabel=rtt, xaxislabel='RTT')
                    self.run_test(my_test, testbed, tag='rtt-%s' % rtt, xticlabel=rtt, xaxislabel='RTT')

                test_collection.add_set(self.testutils)

            self.run_set(my_set, testbed, test_collection.folder + '/' + name, title=title)


if __name__ == '__main__':

    if False:
        testfolders = []
        for type in ['nonect', 'ect1']:
            for i in range(1, 17+1):
                folder = 'testset-speeds/%s/test-%03d' % (type, i)
                Testbed.analyze_results(folder)
                testfolders.append(folder)

        p = Plot()
        p.plot_multiple_flows(testfolders, 'testset-speeds/analysis')

    if False:
        t = OverloadTesting()
        t.test_simple()

    if True:
        t = OverloadTesting()
        t.test_plot_test_data()
