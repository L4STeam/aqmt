#!/usr/bin/env ipython3

# Henrik's test framework

import time
import datetime
import errno
import os
import signal
import sys
import time
import plumbum
from plumbum import local, FG, BG
from plumbum.cmd import bash, tmux, ssh
import subprocess

from calc_queuedelay import QueueDelay
from calc_utilization import Utilization
from plot import Plot

class Common():
    pids_to_kill = []

    @staticmethod
    def require_on_aqm_node():
        bash['-c', 'source ../common.sh; require_on_aqm_node'] & FG

    def kill_known_pids(self):
        for pid in self.pids_to_kill:
            Common.kill_pid(pid)

        self.pids_to_kill = []

    @staticmethod
    def kill_pid(pid):
        try:
            os.kill(pid, signal.SIGTERM)
        except ProcessLookupError:
            pass

    @staticmethod
    def is_running(pid):
        try:
            os.kill(pid, 0)
        except OSError as err:
            if err.errno == errno.ESRCH:
                return False
        return True

    @staticmethod
    def waitpid(pid):
        try:
            os.waitpid(pid, 0)
        except ChildProcessError:
            pass


class Terminal():
    def __init__(self):
        pass

    def cleanup(self):
        pass

    def run_fg(self, cmd, verbose=False):
        cmd = ' '.join(cmd.formulate(10))
        if verbose:
            print(cmd)

        p = bash['-c', cmd].popen(stdin=None, stdout=None, stderr=None, close_fds=True)
        return p.pid

    def run_bg(self, cmd, verbose=False):
        cmd = ' '.join(cmd.formulate(10))
        if verbose:
            print(cmd)

        p = bash['-c', cmd].popen(stdin=subprocess.DEVNULL, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, close_fds=True)
        return p.pid


class Tmux(Terminal):
    win_id = None
    win_bg_id = None

    def __init__(self):
        if 'TMUX' not in os.environ:
            raise Exception("Please run this inside a tmux session")

        self.win_id = tmux['display-message', '-p', '#{window_id}']().strip()
        tmux['set-window-option', '-t', self.win_id, 'remain-on-exit', 'on']()

        self.cleanup()

    def cleanup(self):
        self.kill_dead_panes()

    def kill_dead_panes(self):
        (tmux['list-panes', '-s', '-F', '#{pane_dead} #{pane_id}'] | local['grep']['^1'] | local['awk']['{print $2}'] | local['xargs']['-rL1', 'tmux', 'kill-pane', '-t']).run(retcode=None)

    def run_fg(self, cmd, verbose=False):
        cmd = ' '.join(cmd.formulate(10))
        if verbose:
            print(cmd)

        pane_pid = tmux['split-window', '-dP', '-t', self.win_id, '-F', '#{pane_pid}', cmd]().strip()

        tmux['select-layout', '-t', self.win_id, 'tiled']()
        return int(pane_pid)

    def run_bg(self, cmd, verbose=False):
        cmd = ' '.join(cmd.formulate(10))
        if verbose:
            print(cmd)

        # create the window if needed
        # output in the end should be the new pid of the running command
        # so that we can stop it later
        if not self.have_bg_win():
            res = tmux['new-window', '-dP', '-F', '#{window_id} #{pane_pid}', cmd]().strip().split()
            self.win_bg_id = res[0]
            pane_pid = res[1]
            tmux['set-window-option', '-t', self.win_bg_id, 'remain-on-exit', 'on'] & FG

        else:
            pane_pid = tmux['split-window', '-dP', '-t', self.win_bg_id, '-F', '#{pane_pid}', cmd]().strip()
            tmux['select-layout', '-t', self.win_bg_id, 'tiled'] & FG

        return int(pane_pid)

    def have_bg_win(self):
        if self.win_bg_id == None:
            return False

        res = (tmux['list-windows', '-F', '#{window_id}'] | local['grep'][self.win_bg_id]).run(retcode=None)[1].strip()

        return len(res) > 0


class Testbed():
    bitrate = 1000000
    rtt_clients = 0  # in ms
    rtt_servera = 0  # in ms
    rtt_serverb = 0  # in ms
    aqm_name = ''
    aqm_params = ''
    cc_a = 'cubic'
    ecn_a = 2  # 2 = allow ecn, 1 = force ecn, 0 = no ecn
    cc_b = 'cubic'
    ecn_b = 2

    def aqm_default(self):
        self.aqm_name = ''
        self.aqm_params = ''

    def aqm_pi2(self):
        self.aqm_name = 'pi2'
        self.aqm_params = 'dualq limit 1000'  # l_thresh 10000"

    def aqm_red(self):
        self.aqm_name = 'red'
        self.aqm_params = 'limit 1000000 avpkt 1000 ecn adaptive bandwidth %d' % self.bitrate

    def aqm_dualq(self):
        self.aqm_name = 'dualq'
        self.aqm_params = 'l_thresh_us 1000 offset 0 l_slope 5 c_slope 4 l_smooth 0 c_smooth 5 l_power 1 c_power 2 l_shift 50'

    def setup(self):
        !source ../common.sh; \
            reset_aqm_client_edge; \
            reset_aqm_server_edge; \
            reset_all_hosts_edge; \
            reset_all_hosts_cc; \
            \
            configure_clients_edge $self.bitrate $self.rtt_clients $self.aqm_name "$self.aqm_params"; \
            configure_server_edge $$IP_SERVERA_MGMT $$IP_AQM_SA $$IFACE_SERVERA $$IFACE_ON_SERVERA $self.rtt_servera; \
            configure_server_edge $$IP_SERVERB_MGMT $$IP_AQM_SB $$IFACE_SERVERB $$IFACE_ON_SERVERB $self.rtt_serverb; \
            \
            configure_host_cc $$IP_CLIENTA_MGMT $self.cc_a $self.ecn_a; \
            configure_host_cc $$IP_SERVERA_MGMT $self.cc_a $self.ecn_a; \
            configure_host_cc $$IP_CLIENTB_MGMT $self.cc_b $self.ecn_b; \
            configure_host_cc $$IP_SERVERB_MGMT $self.cc_b $self.ecn_b

    def reset(self):
        return
        !reset_aqm_client_edge
        !reset_aqm_server_edge
        !reset_all_hosts_edge
        !reset_all_hosts_cc

    def get_aqm_options(self, name):
        res = !bash -c 'source ../common.sh; get_aqm_options $name'
        return res.s.strip()

    def print_setup(self):
        print("Configured testbed:")
        print("  rate: %s (applied from router to clients)" % self.bitrate)
        print("  rtt to router:")
        print("    - clients: %d ms" % self.rtt_clients)
        print("    - servera: %d ms" % self.rtt_servera)
        print("    - serverb: %d ms" % self.rtt_serverb)

        if self.aqm_name != '':
            params = ''
            if self.aqm_params != '':
                params = ' (%s)' % self.aqm_params


            print("  aqm: %s%s" % (self.aqm_name, params))
            print("       (%s)" % self.get_aqm_options(self.aqm_name))
        else:
            print("  no aqm")

        for node in ['CLIENTA', 'CLIENTB', 'SERVERA', 'SERVERB']:
            ip = 'IP_%s_MGMT' % node

            print('  %s: ' % node.lower(), end='')
            res = (bash['-c', 'source ../common.sh; get_host_cc "%s"' % ip] | local['tr']['\\n', ' '])().strip()
            print(res)
            #res = !bash -c "source ../common.sh; get_host_cc '$${{$ip}}' | tr '\n' ' '"
            #print(res[0].strip())

    @staticmethod
    def analyze_results(testfolder):
        bitrate = 0
        with open(testfolder + '/details', 'r') as f:
            for line in f:
                if line.startswith('testbed_rate'):
                    bitrate = int(line.split()[1])
                    break

        if bitrate == 0:
            raise Exception("Could not determine bitrate of test '%s'" % testfolder)

        fairness = "e"         # used to calculate rPDF, we don't use it now
        nbrf = 0               # used to calculate rPDF, we don't use it now
        rtt_l4s = 0            # used to calculate window size, we don't use it now
        rtt_classic = 0        # used to calculate window size, we don't use it now
        nbr_l4s_flows = 1      # used to generate rPDF and dmPDF, we don't use it now
        nbr_classic_flows = 1  # used to generate rPDF and dmPDF, we don't use it now

        cmd = local['../../traffic_analyzer/calc_henrste'][testfolder, fairness, str(nbrf), str(bitrate), str(rtt_l4s), str(rtt_classic), str(nbr_l4s_flows), str(nbr_classic_flows)]
        print(' '.join(cmd.formulate(10)))
        cmd()

        qd = QueueDelay()
        qd.processTest(testfolder)

        u = Utilization()
        u.processTest(testfolder, bitrate)

        p = Plot()
        p.plot_flow(testfolder)

    def save_hint(self, file):
        with open(file, 'a') as f:
            f.write("testbed_rtt_clients %d\n" % self.rtt_clients)
            f.write("testbed_rtt_servera %d\n" % self.rtt_servera)
            f.write("testbed_rtt_serverb %d\n" % self.rtt_serverb)
            f.write("testbed_cc_a %s %d\n" % (self.cc_a, self.ecn_a))
            f.write("testbed_cc_b %s %d\n" % (self.cc_b, self.ecn_b))
            f.write("testbed_aqm %s\n" % self.aqm_name)
            f.write("testbed_aqm_params %s\n" % self.aqm_params)
            f.write("testbed_aqm_params_full %s\n" % self.get_aqm_options(self.aqm_name))
            f.write("testbed_rate %s\n" % self.bitrate)


class TestUtils():
    folder_collection = 'testset'
    foldername_test = 'test'
    testnum = 0

    common = None
    terminal = None
    is_interactive = False  # run in tmux or not
    ta_idle = 3  # time to wait before collecting traffic
    ta_delay = 1000
    ta_samples = 60
    traffic_port = 5500

    def __init__(self, common):
        self.common = common

        Common.require_on_aqm_node()

        def exit_gracefully(signum, frame):
            self.common.kill_known_pids()
            self.get_terminal().cleanup()
            sys.exit()

        signal.signal(signal.SIGINT, exit_gracefully)
        signal.signal(signal.SIGTERM, exit_gracefully)

    def get_next_traffic_port(self):
        tmp = self.traffic_port
        self.traffic_port += 1
        return tmp

    def get_terminal(self):
        if self.terminal == None:
            self.terminal = Tmux() if self.is_interactive else Terminal()
        return self.terminal

    def run(self, cmd, bg=False, verbose=False):
        if bg:
            return self.get_terminal().run_bg(cmd, verbose=verbose)
        else:
            return self.get_terminal().run_fg(cmd, verbose=verbose)

    def run_greedy(self, node='a'):
        """
        Run greedy TCP traffic

        Greedy = always data to send, full frames

        node: a or b (a is normally classic traffic, b is normally l4s)

        Returns a lambda to stop the traffic
        """
        server_port = self.get_next_traffic_port()

        node = 'A' if node == 'a' else 'B'

        self.save_hint('traffic=tcp type=greedy node=%s%s server=%s' % (node, node, server_port))

        pid_server = self.run(ssh['-tt', os.environ['IP_SERVER%s_MGMT' % node], '/opt/testbed/greedy_generator/greedy -vv -s %d' % server_port], bg=True, verbose=True)
        self.common.pids_to_kill.append(pid_server)

        pid_client = self.run(ssh['-tt', os.environ['IP_CLIENT%s_MGMT' % node], 'sleep 0.2; /opt/testbed/greedy_generator/greedy -vv %s %d' % (os.environ['IP_SERVER%s' % node], server_port)], bg=True, verbose=True)
        self.common.pids_to_kill.append(pid_client)

        def stopTest():
            Common.kill_pid(pid_server)
            Common.kill_pid(pid_client)

        return stopTest

    def run_udp(self, bitrate, node='a', ect="nonect"):
        """
        Run UDP traffic at a constant bitrate

        ect: ect0 = ECT(0), ect1 = ECT(1), all other is Non-ECT

        Returns a lambda to stop the traffic
        """

        tos = ''
        if ect == 'ect1':
            tos = "--tos 0x01" # ECT(1)
        elif ect == 'ect0':
            tos="--tos 0x02" # ECT(0)
        else:
            ect = 'nonect'

        server_port = self.get_next_traffic_port()

        node = 'A' if node == 'a' else 'B'

        self.save_hint('traffic=udp node=%s%s client=%s rate=%d ect=%s' % (node, node, server_port, bitrate, ect))

        pid = self.run(ssh['-tt', os.environ['IP_CLIENT%s_MGMT' % node], 'iperf -s -p %d' % server_port], bg=True, verbose=True)
        self.common.pids_to_kill.append(pid)

        # bitrate to iperf is the udp data bitrate, not the ethernet frame size as we want
        framesize = 1514
        headers = 42
        length = framesize - headers
        bitrate = bitrate * length / framesize

        pid = self.run(ssh['-tt', os.environ['IP_SERVER%s_MGMT' % node], 'sleep 0.5; iperf -c %s -p %d %s -u -l %d -R -b %d -i 1 -t 99999' %
                          (os.environ['IP_CLIENT%s' % node], server_port, tos, length, bitrate)], bg=True, verbose=True)
        self.common.pids_to_kill.append(pid)

        def stopTest():
            Common.kill_pid(pid)

        return stopTest

    def run_speedometer(self, max_bitrate, delay=0.5):
        max_bitrate = max_bitrate / 8

        pid = self.run(local['speedometer']['-s', '-i', '%f' % delay, '-l', '-t', os.environ['IFACE_CLIENTS'], '-m', '%d' % max_bitrate], verbose=True)
        self.common.pids_to_kill.append(pid)

    def run_ta(self, bg=False):
        net = !echo $IP_AQM_C | sed 's/\.[0-9]\+$/.0/'
        net = net[0]

        pcapfilter = 'ip and dst net %s/24 and (tcp or udp)' % net
        ipclass = 'f'

        pid = self.run(bash['-c', "echo 'Idling a bit before running ta...'; sleep %f; ../../traffic_analyzer/ta $IFACE_CLIENTS '%s' '%s' %d %s %d" %
                       (self.ta_idle, pcapfilter, self.get_testfolder(), self.ta_delay, ipclass, self.ta_samples)], verbose=True, bg=bg)

        # we add it to the kill list in case the script is terminated
        self.common.pids_to_kill.append(pid)

        return pid

    def run_monitor_setup(self):
        pid = self.run(local['watch']['-n', '.2', '../show_setup.sh', '-vir', '%s' % os.environ['IFACE_CLIENTS']], verbose=True)
        self.common.pids_to_kill.append(pid)

    def save_hint_setup(self, text):
        with open(self.folder_collection + '/details', 'a') as f:
            f.write(text + '\n')

    def save_hint(self, text):
        TestUtils.save_hint_to_file(self.get_testfolder(), text)

    @staticmethod
    def save_hint_to_folder(folder, text):
        with open(folder + '/details', 'a') as f:
            f.write(text + '\n')

    def get_testfolder(self):
        tag = '' if self.testtag is None else '-%s' % self.testtag
        return self.folder_collection + '/' + self.foldername_test + '-' + self.get_testnum() + tag

    def get_testnum(self):
        return '%03d' % self.testnum

    def run_test(self, the_test, testbed, tag=None):
        self.testtag = tag

        self.testnum += 1
        testfolder = self.get_testfolder()

        print()
        print()
        print('-------- TESTCASE %s --------' % testfolder)
        print(str(datetime.datetime.now()))
        print()

        start = time.time()

        testbed.reset()
        testbed.setup()

        print('%.2f s: Testbed initialized, starting test' % (time.time()-start))
        print()

        !rm -R $testfolder
        !mkdir -p $testfolder

        testbed.save_hint(testfolder + '/details')

        if self.is_interactive:
            pid_ta = self.run_ta()
            self.run_monitor_setup()
            self.run_speedometer(testbed.bitrate * 1.1, delay=0.05)
        else:
            pid_ta = self.run_ta(bg=True)

        the_test(self, testbed)

        Common.waitpid(pid_ta)  # wait until 'ta' quits
        self.common.kill_known_pids()

        print()
        print('%.2f s: Data collection finished' % (time.time()-start))

        Testbed.analyze_results(self.get_testfolder())
        self.get_terminal().cleanup()

        print()
        print('%.2f s: Plotting complete, test ending' % (time.time()-start))


class TestbedTesting():
    def testbed(self):
        testbed = Testbed()
        testbed.bitrate = 10*1000*1000
        testbed.aqm_pi2()
        testbed.rtt_servera = 25
        testbed.rtt_serverb = 25
        testbed.cc_b = 'dctcp'
        testbed.ecn_b = 1
        return testbed

    def set_up(self):
        common = Common()
        self.testutils = TestUtils(common)

    def tear_down(self):
        self.generate_set_plots()

    def run_set(self, method_set, testbed):
        self.set_up()

        method_set(self.testutils)

        self.tear_down()

    def generate_set_plots(self):
        testfolders = []
        for x in range(1, self.testutils.testnum + 1):
            testfolders.append(self.testutils.folder_collection + '/' + self.testutils.foldername_test + '-' + '%03d' % x)

        p = Plot()
        p.plot_multiple_flows(testfolders, self.testutils.folder_collection + '/analysis')



class OverloadTesting(TestbedTesting):
    def test_simple(self):
        testbed = self.testbed()

        for numflows in [1,2,3]:
            for type in [('cubic', 2, 'cubic'),
                         ('cubic-ecn', 1, 'cubic'),
                         ('dctcp', 1, 'dctcp')]:
                testbed.cc_b = type[2]
                testbed.ecn_b = type[1]

                def my_set(testenv):
                    testenv.folder_collection = 'testset-simple/flows-%d/%s' % (numflows, type[0])

                    for rtt in [2, 5, 10, 25, 50, 75, 100, 125, 150, 175, 200, 250, 300, 400]:
                        testbed.rtt_servera = rtt
                        testbed.rtt_serverb = rtt
                        testenv.ta_idle = (rtt / 1000) * 20 + 4

                        def my_test(testenv, testbed):
                            testenv.save_hint('xlabel %d' % rtt)
                            for i in range(numflows):
                                testenv.run_greedy(node='a')
                                testenv.run_greedy(node='b')

                        testenv.run_test(my_test, testbed)

                self.run_set(my_set, testbed)

    def test_increasing_udp_traffic(self):
        """Test UDP-traffic in both queues with increasing bandwidth"""
        testbed = self.testbed()

        def my_set(testenv):
            testenv.folder_collection = 'testset-a'

            def my_test(testenv, testbed):
                for x in range(10):
                    testenv.run_udp(node='a', bitrate=1250000, ect='nonect')
                    testenv.run_udp(node='b', bitrate=1250000, ect='ect0')
                    time.sleep(2)

            testenv.run_test(my_test, testbed)
            testenv.run_test(my_test, testbed)
            testenv.run_test(my_test, testbed)

        self.run_set(my_set, testbed)

    def test_speeds(self):
        """Test one UDP-flow vs one TCP-greedy flow with different UDP speeds and UDP queue"""
        testbed = self.testbed()

        for ect in ['nonect', 'ect1']:
            def my_set(testenv):
                testenv.folder_collection = 'testset-speeds/' + ect
                testenv.ta_samples = 250
                testenv.ta_delay = 500
                testenv.ta_idle = 5

                speeds = [5000, 9000, 9500, 10000, 10500, 11000, 12000, 12500,
                          13000, 13100, 13200, 13400, 13500, 14000, 28000, 50000, 500000]

                for speed in speeds:
                    def my_test(testenv, testbed):
                        testenv.save_hint('x_udp_rate %d' % (speed * 1000))
                        testenv.run_greedy(node='b')
                        testenv.run_udp(node='a', bitrate=speed*1000, ect=ect)

                    testenv.run_test(my_test, testbed)

            self.run_set(my_set, testbed)

    def test_tcp_competing(self):
        testbed = self.testbed()
        testbed.aqm_pi2()
        testbed.cc_a = 'cubic'
        testbed.ecn_a = 1
        testbed.cc_b = 'cubic'
        testbed.ecn_b = 2

        def my_set(testenv):
            testenv.folder_collection = 'testset-competing'

            def my_test(testenv, testbed):
                testenv.run_greedy(node='a')
                testenv.run_greedy(node='b')

            testenv.run_test(my_test, testbed)

        self.run_set(my_set, testbed)

    def test_plot_test_data(self):
        testbed = self.testbed()
        testbed.aqm_pi2()

        def my_test1(testenv, testbed):
            testenv.run_greedy(node='a')
            testenv.run_greedy(node='b')

        def my_test2(testenv, testbed):
            testenv.run_greedy(node='a')

        def my_test3(testenv, testbed):
            testenv.run_greedy(node='b')

        for name, my_test, title in [('traffic-ab', my_test1, 'traffic both machines'),
                                     ('traffic-a',  my_test2, 'traffic only a'),
                                     ('traffic-b',  my_test3, 'traffic only b')]:
            def my_set(testenv):
                testenv.folder_collection = 'testset-plot-testdata/' + name
                testenv.ta_samples = 5
                testenv.ta_idle = .5
                testenv.ta_delay = 500

                #for rtt in [2, 5, 10, 20, 50]:
                for rtt in [10, 20, 50]:
                    testbed.rtt_servera = testbed.rtt_serverb = rtt
                    testenv.run_test(my_test, testbed, tag='rtt-%s' % rtt)

            self.run_set(my_set, testbed)


if __name__ == '__main__':

    if False:
        testfolders = []
        for type in ['nonect', 'ect1']:
            for i in range(1, 17+1):
                folder = 'testset-speeds/%s/test-%03d' % (type, i)
                Testbed.analyze_results(folder)
                testfolders.append(folder)

        p = Plot()
        p.plot_multiple_flows(testfolders, 'testset-speeds/analysis')

    if False:
        t = OverloadTesting()
        t.test_simple()

    if True:
        t = OverloadTesting()
        t.test_plot_test_data()
